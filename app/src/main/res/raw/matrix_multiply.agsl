uniform shader texA;
uniform shader texB;
uniform int size;

half4 main(vec2 fragCoord) {
    int row = int(fragCoord.y);
    int col = int(fragCoord.x);
    float sum = 0.0;
    float inv = 1.0 / float(size);

    // Unroll loop par bloc de 4
    for (int k = 0; k < size / 4 * 4; k += 4) {
        sum += texA.eval(vec2(float(k) * inv + 0.5*inv, float(row)*inv + 0.5*inv)).r *
               texB.eval(vec2(float(col)*inv + 0.5*inv, float(k)*inv + 0.5*inv)).r;
        sum += texA.eval(vec2(float(k+1) * inv + 0.5*inv, float(row)*inv + 0.5*inv)).r *
               texB.eval(vec2(float(col)*inv + 0.5*inv, float(k+1)*inv + 0.5*inv)).r;
        sum += texA.eval(vec2(float(k+2) * inv + 0.5*inv, float(row)*inv + 0.5*inv)).r *
               texB.eval(vec2(float(col)*inv + 0.5*inv, float(k+2)*inv + 0.5*inv)).r;
        sum += texA.eval(vec2(float(k+3) * inv + 0.5*inv, float(row)*inv + 0.5*inv)).r *
               texB.eval(vec2(float(col)*inv + 0.5*inv, float(k+3)*inv + 0.5*inv)).r;
    }

    // Terminer les restants si size % 4 != 0
    for (int k = size / 4 * 4; k < size; k++) {
        sum += texA.eval(vec2(float(k) * inv + 0.5*inv, float(row)*inv + 0.5*inv)).r *
               texB.eval(vec2(float(col)*inv + 0.5*inv, float(k)*inv + 0.5*inv)).r;
    }

    return half4(sum, 0.0, 0.0, 1.0);
}